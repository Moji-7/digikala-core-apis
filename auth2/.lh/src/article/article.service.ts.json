{
    "sourceFile": "src/article/article.service.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 8,
            "patches": [
                {
                    "date": 1700642947154,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1700643034463,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -35,9 +35,11 @@\n       qb.andWhere(\"article.tagList LIKE :tag\", { tag: `%${query.tag}%` });\r\n     }\r\n \r\n     if ('author' in query) {\r\n-      const author = await this.userRepository.findOne({username: query.author});\r\n+      const author = await this.userRepository.findOne({\r\n+        where: { username: query.author }\r\n+      });\r\n       qb.andWhere(\"article.authorId = :id\", { id: author.id });\r\n     }\r\n \r\n     if ('favorited' in query) {\r\n"
                },
                {
                    "date": 1700644619958,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,227 @@\n+import { Injectable } from '@nestjs/common';\r\n+import { InjectRepository } from '@nestjs/typeorm';\r\n+import { Repository, getRepository, DeleteResult } from 'typeorm';\r\n+import { ArticleEntity } from './article.entity';\r\n+import { Comment } from './comment.entity';\r\n+import { UserEntity } from '../user/user.entity';\r\n+import { FollowsEntity } from '../profile/follows.entity';\r\n+import { CreateArticleDto } from './dto';\r\n+\r\n+import {ArticleRO, ArticlesRO, CommentsRO} from './article.interface';\r\n+const slug = require('slug');\r\n+\r\n+@Injectable()\r\n+export class ArticleService {\r\n+  constructor(\r\n+    @InjectRepository(ArticleEntity)\r\n+    private readonly articleRepository: Repository<ArticleEntity>,\r\n+    @InjectRepository(Comment)\r\n+    private readonly commentRepository: Repository<Comment>,\r\n+    @InjectRepository(UserEntity)\r\n+    private readonly userRepository: Repository<UserEntity>,\r\n+    @InjectRepository(FollowsEntity)\r\n+    private readonly followsRepository: Repository<FollowsEntity>\r\n+  ) {}\r\n+\r\n+  async findAll(query): Promise<ArticlesRO> {\r\n+\r\n+    const qb = await getRepository(ArticleEntity)\r\n+      .createQueryBuilder('article')\r\n+      .leftJoinAndSelect('article.author', 'author');\r\n+\r\n+    qb.where(\"1 = 1\");\r\n+\r\n+    if ('tag' in query) {\r\n+      qb.andWhere(\"article.tagList LIKE :tag\", { tag: `%${query.tag}%` });\r\n+    }\r\n+\r\n+    if ('author' in query) {\r\n+      const author = await this.userRepository.findOne({\r\n+        where: { username: query.author }\r\n+      });\r\n+      qb.andWhere(\"article.authorId = :id\", { id: author.id });\r\n+    }\r\n+\r\n+    if ('favorited' in query) {\r\n+     // const author = await this.userRepository.findOne({username: query.favorited});\r\n+      const author = await this.userRepository.findOne({\r\n+        where: { username: query.favorited }\r\n+      });\r\n+      \r\n+      const ids = author.favorites.map(el => el.id);\r\n+      qb.andWhere(\"article.authorId IN (:ids)\", { ids });\r\n+    }\r\n+\r\n+    qb.orderBy('article.created', 'DESC');\r\n+\r\n+    const articlesCount = await qb.getCount();\r\n+\r\n+    if ('limit' in query) {\r\n+      qb.limit(query.limit);\r\n+    }\r\n+\r\n+    if ('offset' in query) {\r\n+      qb.offset(query.offset);\r\n+    }\r\n+\r\n+    const articles = await qb.getMany();\r\n+\r\n+    return {articles, articlesCount};\r\n+  }\r\n+\r\n+  async findFeed(userId: number, query): Promise<ArticlesRO> {\r\n+    const _follows = await this.followsRepository.find( {followerId: userId});\r\n+\r\n+    if (!(Array.isArray(_follows) && _follows.length > 0)) {\r\n+      return {articles: [], articlesCount: 0};\r\n+    }\r\n+\r\n+    const ids = _follows.map(el => el.followingId);\r\n+\r\n+    const qb = await getRepository(ArticleEntity)\r\n+      .createQueryBuilder('article')\r\n+      .where('article.authorId IN (:ids)', { ids });\r\n+\r\n+    qb.orderBy('article.created', 'DESC');\r\n+\r\n+    const articlesCount = await qb.getCount();\r\n+\r\n+    if ('limit' in query) {\r\n+      qb.limit(query.limit);\r\n+    }\r\n+\r\n+    if ('offset' in query) {\r\n+      qb.offset(query.offset);\r\n+    }\r\n+\r\n+    const articles = await qb.getMany();\r\n+\r\n+    return {articles, articlesCount};\r\n+  }\r\n+\r\n+  async findOne(where): Promise<ArticleRO> {\r\n+    const article = await this.articleRepository.findOne(where);\r\n+    return {article};\r\n+  }\r\n+\r\n+  async addComment(slug: string, commentData): Promise<ArticleRO> {\r\n+    let article  = await this.articleRepository.findOne({\r\n+      where: {slug :  slug}\r\n+    });\r\n+    const comment = new Comment();\r\n+    comment.body = commentData.body;\r\n+\r\n+    article.comments.push(comment);\r\n+\r\n+    await this.commentRepository.save(comment);\r\n+    article = await this.articleRepository.save(article);\r\n+    return {article}\r\n+  }\r\n+\r\n+  async deleteComment(slug: string, id: string): Promise<ArticleRO> {\r\n+  \r\n+    let article  = await this.articleRepository.findOne({\r\n+      where: {slug :  slug}\r\n+    });\r\n+    const comment  = await this.commentRepository.findOne({\r\n+      where: {id : parseInt(id)}\r\n+    });\r\n+    const deleteIndex = article.comments.findIndex(_comment => _comment.id === comment.id);\r\n+\r\n+    if (deleteIndex >= 0) {\r\n+      const deleteComments = article.comments.splice(deleteIndex, 1);\r\n+      await this.commentRepository.delete(deleteComments[0].id);\r\n+      article =  await this.articleRepository.save(article);\r\n+      return {article};\r\n+    } else {\r\n+      return {article};\r\n+    }\r\n+\r\n+  }\r\n+\r\n+  async favorite(id: number, slug: string): Promise<ArticleRO> {\r\n+    let article  = await this.articleRepository.findOne({\r\n+      where: {slug :  slug}\r\n+    });\r\n+    let user  = await this.userRepository.findOne({\r\n+      where: {id :  id}\r\n+    });\r\n+\r\n+    const isNewFavorite = user.favorites.findIndex(_article => _article.id === article.id) < 0;\r\n+    if (isNewFavorite) {\r\n+      user.favorites.push(article);\r\n+      article.favoriteCount++;\r\n+\r\n+      await this.userRepository.save(user);\r\n+      article = await this.articleRepository.save(article);\r\n+    }\r\n+\r\n+    return {article};\r\n+  }\r\n+\r\n+  async unFavorite(id: number, slug: string): Promise<ArticleRO> {\r\n+    let article  = await this.articleRepository.findOne({\r\n+      where: {slug :  slug}\r\n+    });\r\n+    let user  = await this.userRepository.findOne({\r\n+      where: {id :  id}\r\n+    });\r\n+    const deleteIndex = user.favorites.findIndex(_article => _article.id === article.id);\r\n+\r\n+    if (deleteIndex >= 0) {\r\n+\r\n+      user.favorites.splice(deleteIndex, 1);\r\n+      article.favoriteCount--;\r\n+\r\n+      await this.userRepository.save(user);\r\n+      article = await this.articleRepository.save(article);\r\n+    }\r\n+\r\n+    return {article};\r\n+  }\r\n+\r\n+  async findComments(slug: string): Promise<CommentsRO> {\r\n+    const article = await this.articleRepository.findOne({\r\n+      where: {slug :  slug}\r\n+    });\r\n+    return {comments: article.comments};\r\n+  }\r\n+\r\n+  async create(userId: number, articleData: CreateArticleDto): Promise<ArticleEntity> {\r\n+\r\n+    let article = new ArticleEntity();\r\n+    article.title = articleData.title;\r\n+    article.description = articleData.description;\r\n+    article.slug = this.slugify(articleData.title);\r\n+    article.tagList = articleData.tagList || [];\r\n+    article.comments = [];\r\n+\r\n+    const newArticle = await this.articleRepository.save(article);\r\n+\r\n+    const author = await this.userRepository.findOne({ where: { id: userId }, relations: ['articles'] });\r\n+    author.articles.push(article);\r\n+\r\n+    await this.userRepository.save(author);\r\n+\r\n+    return newArticle;\r\n+\r\n+  }\r\n+\r\n+  async update(slug: string, articleData: any): Promise<ArticleRO> {\r\n+     let toUpdate  = await this.articleRepository.findOne({\r\n+      where: {slug :  slug}\r\n+    });\r\n+    \r\n+    let updated = Object.assign(toUpdate, articleData);\r\n+    const article = await this.articleRepository.save(updated);\r\n+    return {article};\r\n+  }\r\n+\r\n+  async delete(slug: string): Promise<DeleteResult> {\r\n+    return await this.articleRepository.delete({ slug: slug});\r\n+  }\r\n+\r\n+  slugify(title: string) {\r\n+    return slug(title, {lower: true}) + '-' + (Math.random() * Math.pow(36, 6) | 0).toString(36)\r\n+  }\r\n+}\r\n"
                },
                {
                    "date": 1700644653226,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -69,9 +69,11 @@\n     return {articles, articlesCount};\r\n   }\r\n \r\n   async findFeed(userId: number, query): Promise<ArticlesRO> {\r\n-    const _follows = await this.followsRepository.find( {followerId: userId});\r\n+    const _follows  = await this.followsRepository.findOne({\r\n+      where: {followerId :  userId}\r\n+    });\r\n \r\n     if (!(Array.isArray(_follows) && _follows.length > 0)) {\r\n       return {articles: [], articlesCount: 0};\r\n     }\r\n@@ -224,214 +226,4 @@\n   slugify(title: string) {\r\n     return slug(title, {lower: true}) + '-' + (Math.random() * Math.pow(36, 6) | 0).toString(36)\r\n   }\r\n }\r\n-import { Injectable } from '@nestjs/common';\r\n-import { InjectRepository } from '@nestjs/typeorm';\r\n-import { Repository, getRepository, DeleteResult } from 'typeorm';\r\n-import { ArticleEntity } from './article.entity';\r\n-import { Comment } from './comment.entity';\r\n-import { UserEntity } from '../user/user.entity';\r\n-import { FollowsEntity } from '../profile/follows.entity';\r\n-import { CreateArticleDto } from './dto';\r\n-\r\n-import {ArticleRO, ArticlesRO, CommentsRO} from './article.interface';\r\n-const slug = require('slug');\r\n-\r\n-@Injectable()\r\n-export class ArticleService {\r\n-  constructor(\r\n-    @InjectRepository(ArticleEntity)\r\n-    private readonly articleRepository: Repository<ArticleEntity>,\r\n-    @InjectRepository(Comment)\r\n-    private readonly commentRepository: Repository<Comment>,\r\n-    @InjectRepository(UserEntity)\r\n-    private readonly userRepository: Repository<UserEntity>,\r\n-    @InjectRepository(FollowsEntity)\r\n-    private readonly followsRepository: Repository<FollowsEntity>\r\n-  ) {}\r\n-\r\n-  async findAll(query): Promise<ArticlesRO> {\r\n-\r\n-    const qb = await getRepository(ArticleEntity)\r\n-      .createQueryBuilder('article')\r\n-      .leftJoinAndSelect('article.author', 'author');\r\n-\r\n-    qb.where(\"1 = 1\");\r\n-\r\n-    if ('tag' in query) {\r\n-      qb.andWhere(\"article.tagList LIKE :tag\", { tag: `%${query.tag}%` });\r\n-    }\r\n-\r\n-    if ('author' in query) {\r\n-      const author = await this.userRepository.findOne({\r\n-        where: { username: query.author }\r\n-      });\r\n-      qb.andWhere(\"article.authorId = :id\", { id: author.id });\r\n-    }\r\n-\r\n-    if ('favorited' in query) {\r\n-     // const author = await this.userRepository.findOne({username: query.favorited});\r\n-      const author = await this.userRepository.findOne({\r\n-        where: { username: query.favorited }\r\n-      });\r\n-      \r\n-      const ids = author.favorites.map(el => el.id);\r\n-      qb.andWhere(\"article.authorId IN (:ids)\", { ids });\r\n-    }\r\n-\r\n-    qb.orderBy('article.created', 'DESC');\r\n-\r\n-    const articlesCount = await qb.getCount();\r\n-\r\n-    if ('limit' in query) {\r\n-      qb.limit(query.limit);\r\n-    }\r\n-\r\n-    if ('offset' in query) {\r\n-      qb.offset(query.offset);\r\n-    }\r\n-\r\n-    const articles = await qb.getMany();\r\n-\r\n-    return {articles, articlesCount};\r\n-  }\r\n-\r\n-  async findFeed(userId: number, query): Promise<ArticlesRO> {\r\n-    const _follows = await this.followsRepository.find( {followerId: userId});\r\n-\r\n-    if (!(Array.isArray(_follows) && _follows.length > 0)) {\r\n-      return {articles: [], articlesCount: 0};\r\n-    }\r\n-\r\n-    const ids = _follows.map(el => el.followingId);\r\n-\r\n-    const qb = await getRepository(ArticleEntity)\r\n-      .createQueryBuilder('article')\r\n-      .where('article.authorId IN (:ids)', { ids });\r\n-\r\n-    qb.orderBy('article.created', 'DESC');\r\n-\r\n-    const articlesCount = await qb.getCount();\r\n-\r\n-    if ('limit' in query) {\r\n-      qb.limit(query.limit);\r\n-    }\r\n-\r\n-    if ('offset' in query) {\r\n-      qb.offset(query.offset);\r\n-    }\r\n-\r\n-    const articles = await qb.getMany();\r\n-\r\n-    return {articles, articlesCount};\r\n-  }\r\n-\r\n-  async findOne(where): Promise<ArticleRO> {\r\n-    const article = await this.articleRepository.findOne(where);\r\n-    return {article};\r\n-  }\r\n-\r\n-  async addComment(slug: string, commentData): Promise<ArticleRO> {\r\n-    let article = await this.articleRepository.findOne({slug});\r\n-\r\n-    const comment = new Comment();\r\n-    comment.body = commentData.body;\r\n-\r\n-    article.comments.push(comment);\r\n-\r\n-    await this.commentRepository.save(comment);\r\n-    article = await this.articleRepository.save(article);\r\n-    return {article}\r\n-  }\r\n-\r\n-  async deleteComment(slug: string, id: string): Promise<ArticleRO> {\r\n-    let article = await this.articleRepository.findOne({slug});\r\n-\r\n-    const comment = await this.commentRepository.findOne(id);\r\n-    const deleteIndex = article.comments.findIndex(_comment => _comment.id === comment.id);\r\n-\r\n-    if (deleteIndex >= 0) {\r\n-      const deleteComments = article.comments.splice(deleteIndex, 1);\r\n-      await this.commentRepository.delete(deleteComments[0].id);\r\n-      article =  await this.articleRepository.save(article);\r\n-      return {article};\r\n-    } else {\r\n-      return {article};\r\n-    }\r\n-\r\n-  }\r\n-\r\n-  async favorite(id: number, slug: string): Promise<ArticleRO> {\r\n-    let article = await this.articleRepository.findOne({slug});\r\n-    const user = await this.userRepository.findOne(id);\r\n-\r\n-    const isNewFavorite = user.favorites.findIndex(_article => _article.id === article.id) < 0;\r\n-    if (isNewFavorite) {\r\n-      user.favorites.push(article);\r\n-      article.favoriteCount++;\r\n-\r\n-      await this.userRepository.save(user);\r\n-      article = await this.articleRepository.save(article);\r\n-    }\r\n-\r\n-    return {article};\r\n-  }\r\n-\r\n-  async unFavorite(id: number, slug: string): Promise<ArticleRO> {\r\n-    let article = await this.articleRepository.findOne({slug});\r\n-    const user = await this.userRepository.findOne(id);\r\n-\r\n-    const deleteIndex = user.favorites.findIndex(_article => _article.id === article.id);\r\n-\r\n-    if (deleteIndex >= 0) {\r\n-\r\n-      user.favorites.splice(deleteIndex, 1);\r\n-      article.favoriteCount--;\r\n-\r\n-      await this.userRepository.save(user);\r\n-      article = await this.articleRepository.save(article);\r\n-    }\r\n-\r\n-    return {article};\r\n-  }\r\n-\r\n-  async findComments(slug: string): Promise<CommentsRO> {\r\n-    const article = await this.articleRepository.findOne({slug});\r\n-    return {comments: article.comments};\r\n-  }\r\n-\r\n-  async create(userId: number, articleData: CreateArticleDto): Promise<ArticleEntity> {\r\n-\r\n-    let article = new ArticleEntity();\r\n-    article.title = articleData.title;\r\n-    article.description = articleData.description;\r\n-    article.slug = this.slugify(articleData.title);\r\n-    article.tagList = articleData.tagList || [];\r\n-    article.comments = [];\r\n-\r\n-    const newArticle = await this.articleRepository.save(article);\r\n-\r\n-    const author = await this.userRepository.findOne({ where: { id: userId }, relations: ['articles'] });\r\n-    author.articles.push(article);\r\n-\r\n-    await this.userRepository.save(author);\r\n-\r\n-    return newArticle;\r\n-\r\n-  }\r\n-\r\n-  async update(slug: string, articleData: any): Promise<ArticleRO> {\r\n-    let toUpdate = await this.articleRepository.findOne({ slug: slug});\r\n-    let updated = Object.assign(toUpdate, articleData);\r\n-    const article = await this.articleRepository.save(updated);\r\n-    return {article};\r\n-  }\r\n-\r\n-  async delete(slug: string): Promise<DeleteResult> {\r\n-    return await this.articleRepository.delete({ slug: slug});\r\n-  }\r\n-\r\n-  slugify(title: string) {\r\n-    return slug(title, {lower: true}) + '-' + (Math.random() * Math.pow(36, 6) | 0).toString(36)\r\n-  }\r\n-}\r\n"
                },
                {
                    "date": 1700644699646,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -68,9 +68,9 @@\n \r\n     return {articles, articlesCount};\r\n   }\r\n \r\n-  async findFeed(userId: number, query): Promise<ArticlesRO> {\r\n+  async findFeed(userId: number, query): Promise<ArticlesRO> {  \r\n     const _follows  = await this.followsRepository.findOne({\r\n       where: {followerId :  userId}\r\n     });\r\n \r\n"
                },
                {
                    "date": 1700650724920,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,7 @@\n import { Injectable } from '@nestjs/common';\r\n-import { InjectRepository } from '@nestjs/typeorm';\r\n-import { Repository, getRepository, DeleteResult } from 'typeorm';\r\n+import { InjectDataSource, InjectRepository } from '@nestjs/typeorm';\r\n+import { Repository, getRepository, DeleteResult, DataSource } from 'typeorm';\r\n import { ArticleEntity } from './article.entity';\r\n import { Comment } from './comment.entity';\r\n import { UserEntity } from '../user/user.entity';\r\n import { FollowsEntity } from '../profile/follows.entity';\r\n@@ -20,8 +20,10 @@\n     @InjectRepository(UserEntity)\r\n     private readonly userRepository: Repository<UserEntity>,\r\n     @InjectRepository(FollowsEntity)\r\n     private readonly followsRepository: Repository<FollowsEntity>\r\n+    @InjectDataSource('albumsConnection')\r\n+    private dataSource: DataSource,\r\n   ) {}\r\n \r\n   async findAll(query): Promise<ArticlesRO> {\r\n \r\n"
                },
                {
                    "date": 1700653150878,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,15 +1,15 @@\n-import { Injectable } from '@nestjs/common';\r\n-import { InjectDataSource, InjectRepository } from '@nestjs/typeorm';\r\n-import { Repository, getRepository, DeleteResult, DataSource } from 'typeorm';\r\n-import { ArticleEntity } from './article.entity';\r\n-import { Comment } from './comment.entity';\r\n-import { UserEntity } from '../user/user.entity';\r\n-import { FollowsEntity } from '../profile/follows.entity';\r\n-import { CreateArticleDto } from './dto';\r\n+import { Injectable } from \"@nestjs/common\";\r\n+import { InjectDataSource, InjectRepository } from \"@nestjs/typeorm\";\r\n+import { Repository, getRepository, DeleteResult, DataSource } from \"typeorm\";\r\n+import { ArticleEntity } from \"./article.entity\";\r\n+import { Comment } from \"./comment.entity\";\r\n+import { UserEntity } from \"../user/user.entity\";\r\n+import { FollowsEntity } from \"../profile/follows.entity\";\r\n+import { CreateArticleDto } from \"./dto\";\r\n \r\n-import {ArticleRO, ArticlesRO, CommentsRO} from './article.interface';\r\n-const slug = require('slug');\r\n+import { ArticleRO, ArticlesRO, CommentsRO } from \"./article.interface\";\r\n+const slug = require(\"slug\");\r\n \r\n @Injectable()\r\n export class ArticleService {\r\n   constructor(\r\n@@ -20,180 +20,186 @@\n     @InjectRepository(UserEntity)\r\n     private readonly userRepository: Repository<UserEntity>,\r\n     @InjectRepository(FollowsEntity)\r\n     private readonly followsRepository: Repository<FollowsEntity>\r\n-    @InjectDataSource('albumsConnection')\r\n-    private dataSource: DataSource,\r\n   ) {}\r\n \r\n   async findAll(query): Promise<ArticlesRO> {\r\n+    // const qb = await getRepository(ArticleEntity)\r\n+    //   .createQueryBuilder('article')\r\n+    //   .leftJoinAndSelect('article.author', 'author');\r\n+    \r\n+    // create a query builder\r\n+    const qb = await this.articleRepository\r\n+      .createQueryBuilder(\"article\")\r\n+      .leftJoinAndSelect(\"article.author\", \"author\");\r\n \r\n-    const qb = await getRepository(ArticleEntity)\r\n-      .createQueryBuilder('article')\r\n-      .leftJoinAndSelect('article.author', 'author');\r\n-\r\n     qb.where(\"1 = 1\");\r\n \r\n-    if ('tag' in query) {\r\n+    if (\"tag\" in query) {\r\n       qb.andWhere(\"article.tagList LIKE :tag\", { tag: `%${query.tag}%` });\r\n     }\r\n \r\n-    if ('author' in query) {\r\n+    if (\"author\" in query) {\r\n       const author = await this.userRepository.findOne({\r\n-        where: { username: query.author }\r\n+        where: { username: query.author },\r\n       });\r\n       qb.andWhere(\"article.authorId = :id\", { id: author.id });\r\n     }\r\n \r\n-    if ('favorited' in query) {\r\n-     // const author = await this.userRepository.findOne({username: query.favorited});\r\n+    if (\"favorited\" in query) {\r\n+      // const author = await this.userRepository.findOne({username: query.favorited});\r\n       const author = await this.userRepository.findOne({\r\n-        where: { username: query.favorited }\r\n+        where: { username: query.favorited },\r\n       });\r\n-      \r\n-      const ids = author.favorites.map(el => el.id);\r\n+\r\n+      const ids = author.favorites.map((el) => el.id);\r\n       qb.andWhere(\"article.authorId IN (:ids)\", { ids });\r\n     }\r\n \r\n-    qb.orderBy('article.created', 'DESC');\r\n+    qb.orderBy(\"article.created\", \"DESC\");\r\n \r\n     const articlesCount = await qb.getCount();\r\n \r\n-    if ('limit' in query) {\r\n+    if (\"limit\" in query) {\r\n       qb.limit(query.limit);\r\n     }\r\n \r\n-    if ('offset' in query) {\r\n+    if (\"offset\" in query) {\r\n       qb.offset(query.offset);\r\n     }\r\n \r\n     const articles = await qb.getMany();\r\n \r\n-    return {articles, articlesCount};\r\n+    return { articles, articlesCount };\r\n   }\r\n \r\n-  async findFeed(userId: number, query): Promise<ArticlesRO> {  \r\n-    const _follows  = await this.followsRepository.findOne({\r\n-      where: {followerId :  userId}\r\n+  async findFeed(userId: number, query): Promise<ArticlesRO> {\r\n+    const _follows = await this.followsRepository.findOne({\r\n+      where: { followerId: userId },\r\n     });\r\n \r\n     if (!(Array.isArray(_follows) && _follows.length > 0)) {\r\n-      return {articles: [], articlesCount: 0};\r\n+      return { articles: [], articlesCount: 0 };\r\n     }\r\n \r\n-    const ids = _follows.map(el => el.followingId);\r\n+    const ids = _follows.map((el) => el.followingId);\r\n \r\n     const qb = await getRepository(ArticleEntity)\r\n-      .createQueryBuilder('article')\r\n-      .where('article.authorId IN (:ids)', { ids });\r\n+      .createQueryBuilder(\"article\")\r\n+      .where(\"article.authorId IN (:ids)\", { ids });\r\n \r\n-    qb.orderBy('article.created', 'DESC');\r\n+    qb.orderBy(\"article.created\", \"DESC\");\r\n \r\n     const articlesCount = await qb.getCount();\r\n \r\n-    if ('limit' in query) {\r\n+    if (\"limit\" in query) {\r\n       qb.limit(query.limit);\r\n     }\r\n \r\n-    if ('offset' in query) {\r\n+    if (\"offset\" in query) {\r\n       qb.offset(query.offset);\r\n     }\r\n \r\n     const articles = await qb.getMany();\r\n \r\n-    return {articles, articlesCount};\r\n+    return { articles, articlesCount };\r\n   }\r\n \r\n   async findOne(where): Promise<ArticleRO> {\r\n     const article = await this.articleRepository.findOne(where);\r\n-    return {article};\r\n+    return { article };\r\n   }\r\n \r\n   async addComment(slug: string, commentData): Promise<ArticleRO> {\r\n-    let article  = await this.articleRepository.findOne({\r\n-      where: {slug :  slug}\r\n+    let article = await this.articleRepository.findOne({\r\n+      where: { slug: slug },\r\n     });\r\n     const comment = new Comment();\r\n     comment.body = commentData.body;\r\n \r\n     article.comments.push(comment);\r\n \r\n     await this.commentRepository.save(comment);\r\n     article = await this.articleRepository.save(article);\r\n-    return {article}\r\n+    return { article };\r\n   }\r\n \r\n   async deleteComment(slug: string, id: string): Promise<ArticleRO> {\r\n-  \r\n-    let article  = await this.articleRepository.findOne({\r\n-      where: {slug :  slug}\r\n+    let article = await this.articleRepository.findOne({\r\n+      where: { slug: slug },\r\n     });\r\n-    const comment  = await this.commentRepository.findOne({\r\n-      where: {id : parseInt(id)}\r\n+    const comment = await this.commentRepository.findOne({\r\n+      where: { id: parseInt(id) },\r\n     });\r\n-    const deleteIndex = article.comments.findIndex(_comment => _comment.id === comment.id);\r\n+    const deleteIndex = article.comments.findIndex(\r\n+      (_comment) => _comment.id === comment.id\r\n+    );\r\n \r\n     if (deleteIndex >= 0) {\r\n       const deleteComments = article.comments.splice(deleteIndex, 1);\r\n       await this.commentRepository.delete(deleteComments[0].id);\r\n-      article =  await this.articleRepository.save(article);\r\n-      return {article};\r\n+      article = await this.articleRepository.save(article);\r\n+      return { article };\r\n     } else {\r\n-      return {article};\r\n+      return { article };\r\n     }\r\n-\r\n   }\r\n \r\n   async favorite(id: number, slug: string): Promise<ArticleRO> {\r\n-    let article  = await this.articleRepository.findOne({\r\n-      where: {slug :  slug}\r\n+    let article = await this.articleRepository.findOne({\r\n+      where: { slug: slug },\r\n     });\r\n-    let user  = await this.userRepository.findOne({\r\n-      where: {id :  id}\r\n+    let user = await this.userRepository.findOne({\r\n+      where: { id: id },\r\n     });\r\n \r\n-    const isNewFavorite = user.favorites.findIndex(_article => _article.id === article.id) < 0;\r\n+    const isNewFavorite =\r\n+      user.favorites.findIndex((_article) => _article.id === article.id) < 0;\r\n     if (isNewFavorite) {\r\n       user.favorites.push(article);\r\n       article.favoriteCount++;\r\n \r\n       await this.userRepository.save(user);\r\n       article = await this.articleRepository.save(article);\r\n     }\r\n \r\n-    return {article};\r\n+    return { article };\r\n   }\r\n \r\n   async unFavorite(id: number, slug: string): Promise<ArticleRO> {\r\n-    let article  = await this.articleRepository.findOne({\r\n-      where: {slug :  slug}\r\n+    let article = await this.articleRepository.findOne({\r\n+      where: { slug: slug },\r\n     });\r\n-    let user  = await this.userRepository.findOne({\r\n-      where: {id :  id}\r\n+    let user = await this.userRepository.findOne({\r\n+      where: { id: id },\r\n     });\r\n-    const deleteIndex = user.favorites.findIndex(_article => _article.id === article.id);\r\n+    const deleteIndex = user.favorites.findIndex(\r\n+      (_article) => _article.id === article.id\r\n+    );\r\n \r\n     if (deleteIndex >= 0) {\r\n-\r\n       user.favorites.splice(deleteIndex, 1);\r\n       article.favoriteCount--;\r\n \r\n       await this.userRepository.save(user);\r\n       article = await this.articleRepository.save(article);\r\n     }\r\n \r\n-    return {article};\r\n+    return { article };\r\n   }\r\n \r\n   async findComments(slug: string): Promise<CommentsRO> {\r\n     const article = await this.articleRepository.findOne({\r\n-      where: {slug :  slug}\r\n+      where: { slug: slug },\r\n     });\r\n-    return {comments: article.comments};\r\n+    return { comments: article.comments };\r\n   }\r\n \r\n-  async create(userId: number, articleData: CreateArticleDto): Promise<ArticleEntity> {\r\n-\r\n+  async create(\r\n+    userId: number,\r\n+    articleData: CreateArticleDto\r\n+  ): Promise<ArticleEntity> {\r\n     let article = new ArticleEntity();\r\n     article.title = articleData.title;\r\n     article.description = articleData.description;\r\n     article.slug = this.slugify(articleData.title);\r\n@@ -201,31 +207,37 @@\n     article.comments = [];\r\n \r\n     const newArticle = await this.articleRepository.save(article);\r\n \r\n-    const author = await this.userRepository.findOne({ where: { id: userId }, relations: ['articles'] });\r\n+    const author = await this.userRepository.findOne({\r\n+      where: { id: userId },\r\n+      relations: [\"articles\"],\r\n+    });\r\n     author.articles.push(article);\r\n \r\n     await this.userRepository.save(author);\r\n \r\n     return newArticle;\r\n-\r\n   }\r\n \r\n   async update(slug: string, articleData: any): Promise<ArticleRO> {\r\n-     let toUpdate  = await this.articleRepository.findOne({\r\n-      where: {slug :  slug}\r\n+    let toUpdate = await this.articleRepository.findOne({\r\n+      where: { slug: slug },\r\n     });\r\n-    \r\n+\r\n     let updated = Object.assign(toUpdate, articleData);\r\n     const article = await this.articleRepository.save(updated);\r\n-    return {article};\r\n+    return { article };\r\n   }\r\n \r\n   async delete(slug: string): Promise<DeleteResult> {\r\n-    return await this.articleRepository.delete({ slug: slug});\r\n+    return await this.articleRepository.delete({ slug: slug });\r\n   }\r\n \r\n   slugify(title: string) {\r\n-    return slug(title, {lower: true}) + '-' + (Math.random() * Math.pow(36, 6) | 0).toString(36)\r\n+    return (\r\n+      slug(title, { lower: true }) +\r\n+      \"-\" +\r\n+      ((Math.random() * Math.pow(36, 6)) | 0).toString(36)\r\n+    );\r\n   }\r\n }\r\n"
                },
                {
                    "date": 1700653246327,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -23,16 +23,16 @@\n     private readonly followsRepository: Repository<FollowsEntity>\r\n   ) {}\r\n \r\n   async findAll(query): Promise<ArticlesRO> {\r\n-    // const qb = await getRepository(ArticleEntity)\r\n-    //   .createQueryBuilder('article')\r\n-    //   .leftJoinAndSelect('article.author', 'author');\r\n+    const qb = await getRepository(ArticleEntity)\r\n+      .createQueryBuilder('article')\r\n+      .leftJoinAndSelect('article.author', 'author');\r\n     \r\n     // create a query builder\r\n-    const qb = await this.articleRepository\r\n-      .createQueryBuilder(\"article\")\r\n-      .leftJoinAndSelect(\"article.author\", \"author\");\r\n+    // const qb = await this.articleRepository\r\n+    //   .createQueryBuilder(\"article\")\r\n+    //   .leftJoinAndSelect(\"article.author\", \"author\");\r\n \r\n     qb.where(\"1 = 1\");\r\n \r\n     if (\"tag\" in query) {\r\n"
                },
                {
                    "date": 1700653297852,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -23,16 +23,16 @@\n     private readonly followsRepository: Repository<FollowsEntity>\r\n   ) {}\r\n \r\n   async findAll(query): Promise<ArticlesRO> {\r\n-    const qb = await getRepository(ArticleEntity)\r\n-      .createQueryBuilder('article')\r\n-      .leftJoinAndSelect('article.author', 'author');\r\n+    // const qb = await getRepository(ArticleEntity)\r\n+    //   .createQueryBuilder('article')\r\n+    //   .leftJoinAndSelect('article.author', 'author');\r\n     \r\n-    // create a query builder\r\n-    // const qb = await this.articleRepository\r\n-    //   .createQueryBuilder(\"article\")\r\n-    //   .leftJoinAndSelect(\"article.author\", \"author\");\r\n+    create a query builder\r\n+    const qb = await this.articleRepository\r\n+      .createQueryBuilder(\"article\")\r\n+      .leftJoinAndSelect(\"article.author\", \"author\");\r\n \r\n     qb.where(\"1 = 1\");\r\n \r\n     if (\"tag\" in query) {\r\n"
                }
            ],
            "date": 1700642947154,
            "name": "Commit-0",
            "content": "import { Injectable } from '@nestjs/common';\r\nimport { InjectRepository } from '@nestjs/typeorm';\r\nimport { Repository, getRepository, DeleteResult } from 'typeorm';\r\nimport { ArticleEntity } from './article.entity';\r\nimport { Comment } from './comment.entity';\r\nimport { UserEntity } from '../user/user.entity';\r\nimport { FollowsEntity } from '../profile/follows.entity';\r\nimport { CreateArticleDto } from './dto';\r\n\r\nimport {ArticleRO, ArticlesRO, CommentsRO} from './article.interface';\r\nconst slug = require('slug');\r\n\r\n@Injectable()\r\nexport class ArticleService {\r\n  constructor(\r\n    @InjectRepository(ArticleEntity)\r\n    private readonly articleRepository: Repository<ArticleEntity>,\r\n    @InjectRepository(Comment)\r\n    private readonly commentRepository: Repository<Comment>,\r\n    @InjectRepository(UserEntity)\r\n    private readonly userRepository: Repository<UserEntity>,\r\n    @InjectRepository(FollowsEntity)\r\n    private readonly followsRepository: Repository<FollowsEntity>\r\n  ) {}\r\n\r\n  async findAll(query): Promise<ArticlesRO> {\r\n\r\n    const qb = await getRepository(ArticleEntity)\r\n      .createQueryBuilder('article')\r\n      .leftJoinAndSelect('article.author', 'author');\r\n\r\n    qb.where(\"1 = 1\");\r\n\r\n    if ('tag' in query) {\r\n      qb.andWhere(\"article.tagList LIKE :tag\", { tag: `%${query.tag}%` });\r\n    }\r\n\r\n    if ('author' in query) {\r\n      const author = await this.userRepository.findOne({username: query.author});\r\n      qb.andWhere(\"article.authorId = :id\", { id: author.id });\r\n    }\r\n\r\n    if ('favorited' in query) {\r\n     // const author = await this.userRepository.findOne({username: query.favorited});\r\n      const author = await this.userRepository.findOne({\r\n        where: { username: query.favorited }\r\n      });\r\n      \r\n      const ids = author.favorites.map(el => el.id);\r\n      qb.andWhere(\"article.authorId IN (:ids)\", { ids });\r\n    }\r\n\r\n    qb.orderBy('article.created', 'DESC');\r\n\r\n    const articlesCount = await qb.getCount();\r\n\r\n    if ('limit' in query) {\r\n      qb.limit(query.limit);\r\n    }\r\n\r\n    if ('offset' in query) {\r\n      qb.offset(query.offset);\r\n    }\r\n\r\n    const articles = await qb.getMany();\r\n\r\n    return {articles, articlesCount};\r\n  }\r\n\r\n  async findFeed(userId: number, query): Promise<ArticlesRO> {\r\n    const _follows = await this.followsRepository.find( {followerId: userId});\r\n\r\n    if (!(Array.isArray(_follows) && _follows.length > 0)) {\r\n      return {articles: [], articlesCount: 0};\r\n    }\r\n\r\n    const ids = _follows.map(el => el.followingId);\r\n\r\n    const qb = await getRepository(ArticleEntity)\r\n      .createQueryBuilder('article')\r\n      .where('article.authorId IN (:ids)', { ids });\r\n\r\n    qb.orderBy('article.created', 'DESC');\r\n\r\n    const articlesCount = await qb.getCount();\r\n\r\n    if ('limit' in query) {\r\n      qb.limit(query.limit);\r\n    }\r\n\r\n    if ('offset' in query) {\r\n      qb.offset(query.offset);\r\n    }\r\n\r\n    const articles = await qb.getMany();\r\n\r\n    return {articles, articlesCount};\r\n  }\r\n\r\n  async findOne(where): Promise<ArticleRO> {\r\n    const article = await this.articleRepository.findOne(where);\r\n    return {article};\r\n  }\r\n\r\n  async addComment(slug: string, commentData): Promise<ArticleRO> {\r\n    let article = await this.articleRepository.findOne({slug});\r\n\r\n    const comment = new Comment();\r\n    comment.body = commentData.body;\r\n\r\n    article.comments.push(comment);\r\n\r\n    await this.commentRepository.save(comment);\r\n    article = await this.articleRepository.save(article);\r\n    return {article}\r\n  }\r\n\r\n  async deleteComment(slug: string, id: string): Promise<ArticleRO> {\r\n    let article = await this.articleRepository.findOne({slug});\r\n\r\n    const comment = await this.commentRepository.findOne(id);\r\n    const deleteIndex = article.comments.findIndex(_comment => _comment.id === comment.id);\r\n\r\n    if (deleteIndex >= 0) {\r\n      const deleteComments = article.comments.splice(deleteIndex, 1);\r\n      await this.commentRepository.delete(deleteComments[0].id);\r\n      article =  await this.articleRepository.save(article);\r\n      return {article};\r\n    } else {\r\n      return {article};\r\n    }\r\n\r\n  }\r\n\r\n  async favorite(id: number, slug: string): Promise<ArticleRO> {\r\n    let article = await this.articleRepository.findOne({slug});\r\n    const user = await this.userRepository.findOne(id);\r\n\r\n    const isNewFavorite = user.favorites.findIndex(_article => _article.id === article.id) < 0;\r\n    if (isNewFavorite) {\r\n      user.favorites.push(article);\r\n      article.favoriteCount++;\r\n\r\n      await this.userRepository.save(user);\r\n      article = await this.articleRepository.save(article);\r\n    }\r\n\r\n    return {article};\r\n  }\r\n\r\n  async unFavorite(id: number, slug: string): Promise<ArticleRO> {\r\n    let article = await this.articleRepository.findOne({slug});\r\n    const user = await this.userRepository.findOne(id);\r\n\r\n    const deleteIndex = user.favorites.findIndex(_article => _article.id === article.id);\r\n\r\n    if (deleteIndex >= 0) {\r\n\r\n      user.favorites.splice(deleteIndex, 1);\r\n      article.favoriteCount--;\r\n\r\n      await this.userRepository.save(user);\r\n      article = await this.articleRepository.save(article);\r\n    }\r\n\r\n    return {article};\r\n  }\r\n\r\n  async findComments(slug: string): Promise<CommentsRO> {\r\n    const article = await this.articleRepository.findOne({slug});\r\n    return {comments: article.comments};\r\n  }\r\n\r\n  async create(userId: number, articleData: CreateArticleDto): Promise<ArticleEntity> {\r\n\r\n    let article = new ArticleEntity();\r\n    article.title = articleData.title;\r\n    article.description = articleData.description;\r\n    article.slug = this.slugify(articleData.title);\r\n    article.tagList = articleData.tagList || [];\r\n    article.comments = [];\r\n\r\n    const newArticle = await this.articleRepository.save(article);\r\n\r\n    const author = await this.userRepository.findOne({ where: { id: userId }, relations: ['articles'] });\r\n    author.articles.push(article);\r\n\r\n    await this.userRepository.save(author);\r\n\r\n    return newArticle;\r\n\r\n  }\r\n\r\n  async update(slug: string, articleData: any): Promise<ArticleRO> {\r\n    let toUpdate = await this.articleRepository.findOne({ slug: slug});\r\n    let updated = Object.assign(toUpdate, articleData);\r\n    const article = await this.articleRepository.save(updated);\r\n    return {article};\r\n  }\r\n\r\n  async delete(slug: string): Promise<DeleteResult> {\r\n    return await this.articleRepository.delete({ slug: slug});\r\n  }\r\n\r\n  slugify(title: string) {\r\n    return slug(title, {lower: true}) + '-' + (Math.random() * Math.pow(36, 6) | 0).toString(36)\r\n  }\r\n}\r\n"
        }
    ]
}